--- E1 ---

sched.c (implementaremos process management y planificador)

Aquí hay una estructura protected_task = VECTOR DE PCBs.

En este, la primera y la última posición no se puede leer o escribir.

Para trabajar con ellos, hay otro puntero, task, que tiene los NR_TASKS (10) posibles task_struct para trabajar

EN ESTA ENTREGA:
----------------
- Crear freequeue (task_structs libres) Todos los task structs libres encolarlos en freequeue
- Crear readyqueue, en boot de sistema estará vacía. Lista de procesos listos para ser ejecutados.

Se declaran o inicializan arriba de sched.c

Para trabajar con las colas: struct list_head 

Dado un list_head, hay que hallar el task-struct que lo contiene. Para ello, implementar listheadtotaskstruct. (hacerlo parecido al current, máscara quitando 12 bits de menor peso para encontrar la dirección)

- Hay que crear el proceso init dentro de init_task1, asignando espacio de direcciones, task_struct, PID, CR3 tabla de paginas del proceso, etc. etc. (explicado en clase)

- Hay que crear proceso IDLE y su contexto de ejecucion (explicado en clase)

- implementar sys_fork para crear procesos nuevos. Igual que el proceso explicado en clase, pero la copia de memoria es diferente. (Datos+Pila tienen asignadas sus propias páginas físicas, Kernel y Código compartidos entre todos los procesos)

- schedule

**************************

Comentario extra que hizo
-------------------------

task_struct *t apunta al task_struct (y al task_union porque apuntan al mismo sitio)

Yo puedo hacer un casting u = ((union task_union*) t) para que apunte a la task_union

Convirtiendo la t de task_struct a task_union puedo acceder a los campos de la t.union

Ahora puedo hacer un u-->stack[..] para acceder en alto nivel a la pila de sistema.

<<Para IDLE no tengo que hacer nada en ensamblador, con esto lo puedo hacer en alto nivel>>

<<Solo hace falta ensamblador si tengo que acceder a registros>>

***************************
