--- E1 ---

sched.c (implementaremos process management y planificador)

Aquí hay una estructura protected_task = VECTOR DE PCBs.

En este, la primera y la última posición no se puede leer o escribir.

Para trabajar con ellos, hay otro puntero, task, que tiene los NR_TASKS (10) posibles task_struct para trabajar

EN ESTA ENTREGA:
----------------
- Crear freequeue (task_structs libres) Todos los task structs libres encolarlos en freequeue
- Crear readyqueue, en boot de sistema estará vacía. Lista de procesos listos para ser ejecutados.

Se declaran o inicializan arriba de sched.c

Para trabajar con las colas: struct list_head 

Dado un list_head, hay que hallar el task-struct que lo contiene. Para ello, implementar listheadtotaskstruct. (hacerlo parecido al current, máscara quitando 12 bits de menor peso para encontrar la dirección)

- Hay que crear el proceso init dentro de init_task1, asignando espacio de direcciones, task_struct, PID, CR3 tabla de paginas del proceso, etc. etc. (explicado en clase)

- Hay que crear proceso IDLE y su contexto de ejecucion (explicado en clase)

- implementar sys_fork para crear procesos nuevos. Igual que el proceso explicado en clase, pero la copia de memoria es diferente. (Datos+Pila tienen asignadas sus propias páginas físicas, Kernel y Código compartidos entre todos los procesos)

- schedule

**************************

Comentario extra que hizo
-------------------------

task_struct *t apunta al task_struct (y al task_union porque apuntan al mismo sitio)

Yo puedo hacer un casting u = ((union task_union*) t) para que apunte a la task_union

Convirtiendo la t de task_struct a task_union puedo acceder a los campos de la t.union

Ahora puedo hacer un u-->stack[..] para acceder en alto nivel a la pila de sistema.

<<Para IDLE no tengo que hacer nada en ensamblador, con esto lo puedo hacer en alto nivel>>

<<Solo hace falta ensamblador si tengo que acceder a registros>>

***************************

PROGRESO:
---------

1) FREEQUEUE:
- Declare  and  initialize a variable named freequeue of type struct list_head. 
//TODO (está de momento en sched.h)

- Modify the declaration of the task_struct structure. Add one field named list that you will use to enqueue the structure into a queue. 
//TODO (está de momento en sched.h)

- Add all task_structs to this queue as, at this moment, all of them are available. /
//TODO (está de momento en sched.h)

- Due to the fact that the list functions are generic, they use a unique type: the struct list_head. So you will need a function to find the memory address of a task_struct given a particular list_head struct  address.  There  is  one  function  named list_head_to_task_struct which  returns  a pointer to a task_struct given a pointer to a list_head struct. Its header is: struct task_struct *list_head_to_task_struct(struct list_head *l);
//TODO (tenías dudas de si había que usarlo para meter las freequeues como list

2) READYQUEUE:
- Declare  and  initialize a variable named readyqueue of type struct list_head. This queue must be initialized during system initialization and it is empty at the beginning.
//TODO (está de momento en sched.h, la inicialización en sys.c)
